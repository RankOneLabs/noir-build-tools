# noir-build-tools

Config-driven build, test, profile, and proving tooling for Noir circuits. Minimal dependencies: `nargo` and `jq` (plus `bb` for proof generation/verification).

## Features
- JSON config, no hardcoded paths
- Compile, test, profile (with budgets), benchmark
- Off-chain proving and verification (`prove`, `verify`, `verifier`)
- On-chain Solidity verifier generation and verification (`sol-verifier`, `sol-verify`)
- Machine-readable output (`--json`, `--csv`), CI-friendly exit codes
- No trusted setup required (UltraHonk)

## Requirements
- `nargo` (includes `noir-profiler`)
- `jq`
- `bb` (Barretenberg) for proof generation and verification

## Install
```bash
./install.sh
export PATH="$HOME/.local/bin:$PATH"
```

## Quickstart
```bash
nbt init                       # create nbt.config.json
nbt list                       # list circuits
nbt compile my_circuit         # compile one circuit
nbt test --all                 # run tests for all circuits
nbt profile --all              # profile constraints, exits 1 if over budget
nbt benchmark my_circuit --csv # timing benchmarks
nbt report --all               # JSON report of constraints/budgets
nbt doctor                     # check environment health

# Off-chain proving workflow
nbt verifier my_circuit        # generate verification key
nbt testdata my_inputs.yaml -o Prover.toml # generate valid test inputs
nbt prove my_circuit           # generate proof (auto-generates VK if needed)
nbt verify my_circuit          # verify proof

# On-chain (Solidity) workflow
nbt sol-verifier my_circuit    # generate Solidity verifier contract
nbt deploy my_circuit          # deploy verifier (via forge)
nbt sol-verify my_circuit      # verify proof on-chain
```

## Commands

### Setup & Info
- `nbt init`: Creates `nbt.config.json` in the current directory.
- `nbt list`: Prints circuits from the config with their paths and budgets.
- `nbt doctor`: Checks environment for required tools (jq, nargo, bb).

### Build, Test & Prove
- `nbt compile [name|--all]`: Runs `nargo compile` in each circuit directory.
- `nbt test [name|--all]`: Runs `nargo test` in each circuit directory.
- `nbt profile [name|--all]`: Runs `nargo info`, sums constraints, and exits 1 if over `constraintBudget`.
- `nbt benchmark [name|--all] [--csv]`: Runs `nargo execute` multiple times and reports timing.
- `nbt report [name|--all]`: Emits JSON summarizing constraints/budgets.
- `nbt testdata [config.yaml]`: Generates valid `Prover.toml` inputs using a declarative YAML spec (see [docs/test_data_generation.md](docs/test_data_generation.md)).
- `nbt prove [name]`: Compiles, executes witness, generates VK (if needed), and produces proof to `target/proof`. Also outputs `target/public_inputs`.

### Off-chain Verification (requires `bb`)
- `nbt verifier [name]`: Generates verification key (VK) to `target/vk`.
- `nbt verify [name]`: Verifies a proof off-chain using VK, proof, and public inputs.

### On-chain (Solidity) Workflow (requires `bb` + Foundry)
> Note: Verify commands require a proof generated by `nbt prove`.
- `nbt sol-verifier [name]`: Generates Solidity verifier contract to `paths.verifiers/<circuit>/`.
- `nbt deploy [name]`: Deploys `paths.verifiers/<circuit>/Verifier.sol` via `forge create`. Env vars: `RPC_URL`, `PRIVATE_KEY`, `CONTRACT_NAME`, `CHAIN_ID`. Auto-deploys libraries, saves deployment metadata to `deployment-<chainId>.json`.
- `nbt sol-verify [name]`: Verifies a proof on-chain against deployed Solidity verifier.

## End-to-end local workflow (example)
1) **Install tools**
```bash
cd ~/codes/rol/noir-build-tools
./install.sh
export PATH="$HOME/.local/bin:$PATH"
# Optional: export NOIR_BUILD_TOOLS_LIB="/absolute/path/to/lib" if the libs are elsewhere
```

2) **Create config** where you want to work (no circuit required yet)
```bash
cd /path/to/your/noir/project
nbt init
```

3) **Point circuits to their folders** (edit `nbt.config.json`)
- For each circuit, set `circuits[].path` to the directory containing its `Nargo.toml` (often `./` or `circuits/<name>`).
- Optional fields: `constraintBudget`, `benchmarkRuns`, `paths.reports`, `paths.verifiers`, `backend.path` (default `bb`).

4) **Inspect config**
```bash
nbt list
```

5) **Compile**
```bash
nbt compile --all     # or nbt compile my_circuit
```

6) **Test**
```bash
nbt test --all        # or nbt test my_circuit
```

7) **Profile constraints (budget check)**
```bash
nbt profile --all     # exits 1 if any circuit exceeds its constraintBudget
```

8) **Benchmark execution time**
```bash
nbt benchmark my_circuit --csv  # averages over benchmarkRuns
```

9) **Generate test data**
```bash
nbt testdata my_inputs.yaml -o Prover.toml
# Generates valid Prover.toml from declarative YAML spec
```

10) **Generate proof** (requires `bb`)
```bash
nbt prove my_circuit
# Compiles circuit, generates witness from Prover.toml, creates VK if needed, outputs proof
# Outputs: target/proof, target/public_inputs, target/vk
```

11) **Verify proof off-chain**
```bash
nbt verify my_circuit
# Verifies target/proof against target/vk using target/public_inputs
```

12) **Generate Solidity verifier** (on-chain, requires `bb`)
```bash
nbt sol-verifier my_circuit
# Outputs Verifier.sol to paths.verifiers/<circuit>/ (default ./contracts/verifiers/<circuit>/)
```

13) **Deploy the verifier** (requires Foundry)
```bash
nbt deploy my_circuit --rpc-url http://127.0.0.1:8545 --private-key 0x...
# Defaults: rpc=http://127.0.0.1:8545, key=anvil default, contract name=HonkVerifier
# Auto-deploys/link any libraries, broadcasts by default, and writes deployment-<chainId>.json
# Add --dry-run (or DRY_RUN=true) to skip broadcasting
```

14) **Produce a machine-readable report**
```bash
nbt report --all > reports/summary.json
```

15) **Test verifier on a local chain** (example flow)
- Start a local EVM (e.g., `anvil` or `hardhat node`).
- Compile and deploy the generated Solidity verifier with your preferred tool (Foundry/Hardhat/Remix) using the vk and verifier artifacts from `paths.verifiers/<circuit>/` (file name is always Verifier.sol).
- Generate a proof with `bb` or your proving pipeline, then call the verifier contract’s verify function on the local chain to confirm it accepts a valid proof and rejects an invalid one.

### Foundry deploy/test (minimal example)
Assumes `nbt verifier my_circuit` produced `contracts/verifiers/my_circuit/Verifier.sol` plus `proof` and `public_inputs` (newline-separated hex field elements) in your circuit’s `target/`.

1) Start a local chain in one terminal:
```bash
anvil --block-time 2 --chain-id 31337
```

2) Deploy the verifier (contract name is typically `HonkVerifier` in the generated Solidity):
```bash
cd /path/to/your/noir/project
forge create \
	--rpc-url http://127.0.0.1:8545 \
	--private-key 0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80 \ # anvil default key[0]
	./contracts/verifiers/<circuit>/Verifier.sol:HonkVerifier
# capture the deployed address from the output
```

3) Call `verify` with your proof and public inputs:
```bash
VERIFIER=<deployed_address>
PROOF=$(cat target/proof)  # expects 0x-prefixed hex
PUBS=$(tr '\n' ',' < target/public_inputs | sed 's/,$//')
cast call $VERIFIER "verify(bytes,bytes32[])" $PROOF "[$PUBS]" --rpc-url http://127.0.0.1:8545
```

Notes:
- If your generated verifier contract has a different name, adjust the `forge create` target accordingly.
- If `public_inputs` is emitted in another format (JSON, abi-encoded), convert it to a comma-separated list of 0x-prefixed 32-byte values for the `bytes32[]` argument.
- You can also wrap steps 2–3 in a Foundry script that reads `target/proof` and `target/public_inputs` from disk and asserts `verify(...) == true`.

#### Foundry script (ready to run)
Example script at `examples/foundry/VerifyLocal.s.sol`. Copy it into your project’s `script/` folder and update the import path to your generated verifier (default `contracts/verifiers/<circuit>/<circuit>Verifier.sol`). It expects:
- `target/proof` containing the proof bytes (0x-prefixed hex).
- `target/public_inputs.json` containing `{ "public_inputs": ["0x...", "0x..."] }`.

Convert `public_inputs` (newline-separated hex) to JSON:
```bash
jq -R -s 'split("\n")[:-1] | {public_inputs: map(select(length>0))}' target/public_inputs > target/public_inputs.json
```

Run the script (after deploying the verifier and exporting `VERIFIER_ADDRESS`):
```bash
forge script script/VerifyLocal.s.sol \
	--rpc-url http://127.0.0.1:8545 \
	--private-key 0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80 \
	--broadcast
```
The script reads the proof/public inputs from disk and calls `verify(...)`; it reverts if verification fails.

Tips:
- Commands auto-discover `nbt.config.json` by walking up directories; run them anywhere under your project tree.
- Make sure each `circuits[].path` actually contains `Nargo.toml`; `nargo` resolves `src/main.nr` from there.
- If you see `lib/utils.sh not found`, reinstall or set `NOIR_BUILD_TOOLS_LIB` to the repo’s `lib` directory.

## Config
See `templates/nbt.config.json` for schema. Key fields: `circuits[].name`, `circuits[].path`, optional `constraintBudget`, `benchmarkRuns`, `paths.reports`, `paths.verifiers`, `backend.path`.

## Testing
Run the test suite (requires [bats](https://github.com/bats-core/bats-core)):
```bash
./tests/run-tests.sh
```

Tests include:
- `tests/commands.bats`: Unit tests for command help/usage
- `tests/integration.bats`: End-to-end tests with real circuits (compile, prove, verify)
- `tests/report.bats`: Tests for report generation and output formats
- `tests/benchmark.bats`: Tests for benchmarking workflows and performance runs

## CI Example
See `examples/github-workflow.yml` for GitHub Actions usage.

## Test Data Engine
The `nbt testdata` command is powered by a standalone Node.js application located in `lib/testdata/`.
It uses a declarative YAML engine to generate cryptographic inputs (signatures, hashes) without requiring project-specific scripts.
See [lib/testdata/README.md](lib/testdata/README.md) for architecture details.

## License
MIT
