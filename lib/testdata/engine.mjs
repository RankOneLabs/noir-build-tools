import yaml from 'js-yaml';
import * as fs from 'node:fs';
import * as primitives from './primitives.mjs';

// Helper to resolve values (literals or $variables)
function resolve(val, ctx) {
    if (typeof val === 'string' && val.startsWith('$')) {
        const path = val.slice(1).split('.');
        let res = ctx;
        for (const p of path) {
            if (res === undefined) break;
            res = res[p];
        }
        if (res === undefined) {
            throw new Error(`Variable not found: ${val}`);
        }
        return res;
    }
    // Resolve array contents recursively
    if (Array.isArray(val)) {
        return val.map(v => resolve(v, ctx));
    }
    return val;
}

export default {
    async execute(yamlPath, cliOptions) {
        if (!fs.existsSync(yamlPath)) {
            throw new Error(`Config file not found: ${yamlPath}`);
        }
        const content = fs.readFileSync(yamlPath, 'utf8');
        const spec = yaml.load(content);

        // 1. Initialize Context with Inputs
        // Built-in $NOW variable for current date
        const now = new Date();
        const builtIns = {
            NOW: {
                year: now.getFullYear(),
                month: now.getMonth() + 1,
                day: now.getDate(),
            },
        };
        // Inputs defined in YAML can be overridden by CLI options (future)
        const ctx = { ...builtIns, ...spec.inputs, ...cliOptions };

        // 2. Execute Pipeline
        if (spec.pipeline) {
            for (const step of spec.pipeline) {
                try {
                    const op = primitives[step.op];
                    if (!op) throw new Error(`Unknown operation: ${step.op}`);

                    // Resolve arguments
                    let args = [];
                    if (step.args) {
                        args = resolve(step.args, ctx);
                    } else if (step.message) {
                        // Start of specific adapters for convenience
                        const msg = resolve(step.message, ctx);
                        const key = step.key ? resolve(step.key, ctx) : null;
                        args = [msg, key];
                    }

                    const result = await op(...args);
                    ctx[step.id] = result;
                } catch (err) {
                    throw new Error(`Step "${step.id}" (${step.op}) failed: ${err.message}`);
                }
            }
        }

        // 3. Format Output
        let output = `# Auto-generated by nbt testdata from ${yamlPath}\n`;
        output += `# Timestamp: ${new Date().toISOString()}\n\n`;

        function formatValue(v) {
            if (v instanceof Uint8Array) return primitives.toTomlArray(v);
            return v;
        }

        for (const [key, valExpr] of Object.entries(spec.outputs)) {
            const val = resolve(valExpr, ctx);
            output += `${key} = ${formatValue(val)}\n`;
        }

        return output;
    }
};
